import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { z } from 'zod';
import { createTicketAIService } from '../services/ticketAI';
import { createVectorSearchService } from '../services/vectorSearch';

// Request schemas
const TicketAnalysisRequestSchema = z.object({
  include_suggestions: z.boolean().optional().default(true),
  include_sentiment: z.boolean().optional().default(true),
  include_routing: z.boolean().optional().default(true)
});

const BulkAnalysisRequestSchema = z.object({
  ticket_ids: z.array(z.number().int().positive()).min(1).max(20),
  priority_only: z.boolean().optional().default(false)
});

const SmartSearchRequestSchema = z.object({
  query: z.string().min(1).max(500),
  search_type: z.enum(['tickets', 'knowledge', 'mixed']).optional().default('mixed'),
  include_ai_insights: z.boolean().optional().default(true),
  limit: z.number().int().min(1).max(50).optional().default(20),
  filters: z.object({
    site_id: z.number().int().positive().optional(),
    status: z.array(z.string()).optional(),
    priority: z.array(z.string()).optional(),
    date_range: z.object({
      start: z.string().datetime(),
      end: z.string().datetime()
    }).optional()
  }).optional()
});

export default async function ticketAIRoutes(fastify: FastifyInstance) {

  // Comprehensive ticket AI analysis
  fastify.get<{
    Params: { ticketId: string }
    Querystring: z.infer<typeof TicketAnalysisRequestSchema>
  }>('/tickets/:ticketId/ai-analysis', {
    schema: {
      description: 'Get comprehensive AI analysis for a ticket including categorization, priority suggestions, similar tickets, and knowledge base recommendations',
      tags: ['Ticket AI'],
      params: z.object({
        ticketId: z.string().regex(/^\d+$/)
      }),
      querystring: TicketAnalysisRequestSchema,
      security: [{ bearerAuth: [] }]
    }
  }, async (request: FastifyRequest<{
    Params: { ticketId: string }
    Querystring: z.infer<typeof TicketAnalysisRequestSchema>
  }>, reply: FastifyReply) => {
    const startTime = Date.now();
    
    try {
      const ticketId = parseInt(request.params.ticketId);
      const { include_suggestions, include_sentiment, include_routing } = request.query;

      const aiService = await createTicketAIService(request);
      const analysis = await aiService.analyzeTicket(ticketId);

      // Filter results based on request options
      if (!include_suggestions) {
        analysis.knowledge_suggestions = [];
      }

      if (!include_sentiment) {
        delete analysis.sentiment_analysis;
      }

      if (!include_routing) {
        delete analysis.suggested_assignment;
      }

      const processingTime = Date.now() - startTime;

      return reply.send({
        success: true,
        analysis,
        processing_time_ms: processingTime
      });

    } catch (error) {
      const processingTime = Date.now() - startTime;
      fastify.log.error({ error }, 'Ticket AI analysis failed');
      
      return reply.status(500).send({
        success: false,
        analysis: {
          ticket_id: parseInt(request.params.ticketId),
          similar_tickets: [],
          knowledge_suggestions: []
        },
        processing_time_ms: processingTime,
        message: error instanceof Error ? error.message : 'AI analysis failed'
      });
    }
  });

  // Quick ticket classification endpoint
  fastify.post<{
    Body: { content: string; site_id?: number; asset_id?: number }
  }>('/tickets/ai-classify', {
    schema: {
      description: 'Classify ticket content to suggest category and priority',
      tags: ['Ticket AI'],
      body: z.object({
        content: z.string().min(1).max(2000),
        site_id: z.number().int().positive().optional(),
        asset_id: z.number().int().positive().optional()
      }),
      response: {
        200: z.object({
          success: z.boolean(),
          classification: z.object({
            category: z.object({
              suggested: z.string(),
              confidence: z.number(),
              alternatives: z.array(z.object({
                category: z.string(),
                confidence: z.number()
              }))
            }),
            priority: z.object({
              suggested: z.enum(['Low', 'Medium', 'High', 'Critical']),
              confidence: z.number(),
              reasoning: z.string()
            }),
            urgency_score: z.number(),
            urgency_indicators: z.array(z.string())
          }),
          processing_time_ms: z.number()
        })
      },
      security: [{ bearerAuth: [] }]
    }
  }, async (request: FastifyRequest<{
    Body: { content: string; site_id?: number; asset_id?: number }
  }>, reply: FastifyReply) => {
    const startTime = Date.now();
    
    try {
      const { content, site_id, asset_id } = request.body;

      const aiService = await createTicketAIService(request);
      
      // Create mock ticket object for analysis
      const mockTicket = { site_id, asset_id };
      
      const [categoryResult, priorityResult, sentimentResult] = await Promise.all([
        aiService.classifyTicket(content),
        aiService.analyzePriority(content, mockTicket),
        aiService.analyzeSentiment(content)
      ]);

      const processingTime = Date.now() - startTime;

      return reply.send({
        success: true,
        classification: {
          category: {
            suggested: categoryResult.category,
            confidence: categoryResult.confidence,
            alternatives: categoryResult.alternatives
          },
          priority: {
            suggested: priorityResult.priority,
            confidence: priorityResult.confidence,
            reasoning: `Analysis based on content keywords and context`
          },
          urgency_score: Math.abs(sentimentResult.score),
          urgency_indicators: sentimentResult.urgency_indicators
        },
        processing_time_ms: processingTime
      });

    } catch (error) {
      const processingTime = Date.now() - startTime;
      fastify.log.error({ error }, 'Ticket classification failed');
      
      return reply.status(500).send({
        success: false,
        classification: {
          category: {
            suggested: 'General',
            confidence: 0.1,
            alternatives: []
          },
          priority: {
            suggested: 'Medium',
            confidence: 0.1,
            reasoning: 'Default fallback'
          },
          urgency_score: 0.5,
          urgency_indicators: []
        },
        processing_time_ms: processingTime
      });
    }
  });

  // Bulk ticket analysis for dashboard insights
  fastify.post<{
    Body: z.infer<typeof BulkAnalysisRequestSchema>
  }>('/tickets/ai-bulk-analysis', {
    schema: {
      description: 'Perform bulk AI analysis on multiple tickets for dashboard insights',
      tags: ['Ticket AI'],
      body: BulkAnalysisRequestSchema,
      response: {
        200: z.object({
          success: z.boolean(),
          results: z.array(z.object({
            ticket_id: z.number(),
            suggested_priority: z.string().optional(),
            priority_confidence: z.number().optional(),
            urgency_score: z.number().optional(),
            category_suggestion: z.string().optional(),
            auto_actions_count: z.number().optional(),
            error: z.string().optional()
          })),
          summary: z.object({
            total_analyzed: z.number(),
            successful: z.number(),
            failed: z.number(),
            high_urgency_count: z.number(),
            processing_time_ms: z.number()
          })
        })
      },
      security: [{ bearerAuth: [] }]
    }
  }, async (request: FastifyRequest<{
    Body: z.infer<typeof BulkAnalysisRequestSchema>
  }>, reply: FastifyReply) => {
    const startTime = Date.now();
    
    try {
      const { ticket_ids, priority_only } = request.body;

      const aiService = await createTicketAIService(request);
      const results = [];
      let successful = 0;
      let failed = 0;
      let highUrgencyCount = 0;

      // Process tickets in parallel with concurrency limit
      const concurrencyLimit = 5;
      for (let i = 0; i < ticket_ids.length; i += concurrencyLimit) {
        const batch = ticket_ids.slice(i, i + concurrencyLimit);
        const batchPromises = batch.map(async (ticketId) => {
          try {
            if (priority_only) {
              // Quick priority analysis only
              const ticket = await aiService.getTicketDetails(ticketId);
              if (ticket) {
                const content = aiService.buildTicketContent(ticket);
                const priorityResult = await aiService.analyzePriority(content, ticket);
                const sentimentResult = await aiService.analyzeSentiment(content);
                
                if (sentimentResult.urgency_indicators.length > 1) {
                  highUrgencyCount++;
                }

                return {
                  ticket_id: ticketId,
                  suggested_priority: priorityResult.priority,
                  priority_confidence: priorityResult.confidence,
                  urgency_score: Math.abs(sentimentResult.score)
                };
              }
            } else {
              // Full analysis
              const analysis = await aiService.analyzeTicket(ticketId);
              
              if (analysis.sentiment_analysis && analysis.sentiment_analysis.urgency_indicators.length > 1) {
                highUrgencyCount++;
              }

              return {
                ticket_id: ticketId,
                suggested_priority: analysis.suggested_priority,
                priority_confidence: 0.8, // Placeholder
                urgency_score: analysis.sentiment_analysis ? Math.abs(analysis.sentiment_analysis.score) : 0.5,
                category_suggestion: analysis.suggested_category,
                auto_actions_count: analysis.auto_actions ? analysis.auto_actions.length : 0
              };
            }

            successful++;
            return null;

          } catch (error) {
            failed++;
            return {
              ticket_id: ticketId,
              error: error instanceof Error ? error.message : 'Analysis failed'
            };
          }
        });

        const batchResults = await Promise.all(batchPromises);
        results.push(...batchResults.filter(Boolean));
      }

      const processingTime = Date.now() - startTime;

      return reply.send({
        success: true,
        results,
        summary: {
          total_analyzed: ticket_ids.length,
          successful,
          failed,
          high_urgency_count: highUrgencyCount,
          processing_time_ms: processingTime
        }
      });

    } catch (error) {
      const processingTime = Date.now() - startTime;
      fastify.log.error({ error }, 'Bulk ticket analysis failed');
      
      return reply.status(500).send({
        success: false,
        results: [],
        summary: {
          total_analyzed: 0,
          successful: 0,
          failed: request.body.ticket_ids.length,
          high_urgency_count: 0,
          processing_time_ms: processingTime
        }
      });
    }
  });

  // Smart search across tickets and knowledge base
  fastify.post<{
    Body: z.infer<typeof SmartSearchRequestSchema>
  }>('/search/smart', {
    schema: {
      description: 'Perform intelligent search across tickets and knowledge base with AI insights',
      tags: ['Search', 'Ticket AI'],
      body: SmartSearchRequestSchema,
      response: {
        200: z.object({
          success: z.boolean(),
          results: z.object({
            tickets: z.array(z.object({
              ticket_id: z.number(),
              title: z.string(),
              similarity_score: z.number(),
              status: z.string(),
              priority: z.string().optional(),
              site_name: z.string().optional(),
              created_at: z.date(),
              ai_insights: z.object({
                relevance_reason: z.string(),
                suggested_actions: z.array(z.string())
              }).optional()
            })),
            knowledge: z.array(z.object({
              snippet_id: z.number(),
              title: z.string(),
              similarity_score: z.number(),
              content_preview: z.string(),
              source_type: z.string(),
              ai_insights: z.object({
                applicability: z.string(),
                confidence: z.number()
              }).optional()
            })),
            suggestions: z.object({
              related_queries: z.array(z.string()),
              filter_suggestions: z.array(z.string()),
              category_insights: z.array(z.object({
                category: z.string(),
                relevance: z.number()
              }))
            }).optional()
          }),
          search_stats: z.object({
            total_results: z.number(),
            search_time_ms: z.number(),
            ai_processing_time_ms: z.number(),
            query_enhancement: z.string().optional()
          })
        })
      },
      security: [{ bearerAuth: [] }]
    }
  }, async (request: FastifyRequest<{
    Body: z.infer<typeof SmartSearchRequestSchema>
  }>, reply: FastifyReply) => {
    const startTime = Date.now();
    const aiStartTime = Date.now();
    
    try {
      const { query, search_type, include_ai_insights, limit, filters } = request.body;

      const vectorService = await createVectorSearchService(request);
      const searchOptions = {
        query,
        limit,
        threshold: 0.2,
        includeContent: false,
        filters: filters ? {
          siteId: filters.site_id,
          dateRange: filters.date_range ? {
            start: new Date(filters.date_range.start),
            end: new Date(filters.date_range.end)
          } : undefined
        } : undefined
      };

      let ticketResults: any[] = [];
      let knowledgeResults: any[] = [];

      if (search_type === 'tickets' || search_type === 'mixed') {
        const ticketSearch = await vectorService.search({
          ...searchOptions,
          filters: {
            ...searchOptions.filters,
            entityType: 'ticket'
          }
        });
        ticketResults = ticketSearch.results;
      }

      if (search_type === 'knowledge' || search_type === 'mixed') {
        const knowledgeSearch = await vectorService.search({
          ...searchOptions,
          filters: {
            ...searchOptions.filters,
            entityType: 'snippet'
          }
        });
        knowledgeResults = knowledgeSearch.results;
      }

      const aiProcessingTime = Date.now() - aiStartTime;

      // Add AI insights if requested
      let aiInsights = {};
      if (include_ai_insights) {
        aiInsights = {
          suggestions: {
            related_queries: generateRelatedQueries(query),
            filter_suggestions: generateFilterSuggestions(ticketResults, knowledgeResults),
            category_insights: analyzeCategoryInsights(ticketResults)
          }
        };
      }

      const searchTime = Date.now() - startTime;

      return reply.send({
        success: true,
        results: {
          tickets: ticketResults.map((result: any) => ({
            ticket_id: result.metadata.entity_id || result.id,
            title: result.title,
            similarity_score: result.similarity_score,
            status: result.metadata.status || 'Unknown',
            priority: result.metadata.priority,
            site_name: result.metadata.site_name,
            created_at: result.metadata.created_at,
            ai_insights: include_ai_insights ? {
              relevance_reason: generateRelevanceReason(result.similarity_score),
              suggested_actions: generateSuggestedActions(result)
            } : undefined
          })),
          knowledge: knowledgeResults.map((result: any) => ({
            snippet_id: result.id,
            title: result.title,
            similarity_score: result.similarity_score,
            content_preview: result.summary || '',
            source_type: result.metadata.source || 'Unknown',
            ai_insights: include_ai_insights ? {
              applicability: generateApplicabilityText(result.similarity_score),
              confidence: result.similarity_score
            } : undefined
          })),
          ...aiInsights
        },
        search_stats: {
          total_results: ticketResults.length + knowledgeResults.length,
          search_time_ms: searchTime,
          ai_processing_time_ms: aiProcessingTime,
          query_enhancement: enhanceQuery(query)
        }
      });

    } catch (error) {
      const searchTime = Date.now() - startTime;
      fastify.log.error({ error }, 'Smart search failed');
      
      return reply.status(500).send({
        success: false,
        results: {
          tickets: [],
          knowledge: []
        },
        search_stats: {
          total_results: 0,
          search_time_ms: searchTime,
          ai_processing_time_ms: 0
        }
      });
    }
  });
}

// Helper functions for AI insights
function generateRelatedQueries(query: string): string[] {
  const baseTerms = query.toLowerCase().split(' ');
  const suggestions = [];
  
  // Simple related query generation
  if (baseTerms.includes('error')) {
    suggestions.push('troubleshooting steps', 'error resolution');
  }
  if (baseTerms.includes('slow')) {
    suggestions.push('performance issues', 'optimization');
  }
  if (baseTerms.includes('login')) {
    suggestions.push('authentication problems', 'user access');
  }
  
  return suggestions.slice(0, 3);
}

function generateFilterSuggestions(ticketResults: any[], knowledgeResults: any[]): string[] {
  const suggestions = [];
  
  if (ticketResults.length > 10) {
    suggestions.push('Filter by status or priority');
  }
  if (knowledgeResults.length > 5) {
    suggestions.push('Filter by document type');
  }
  
  return suggestions;
}

function analyzeCategoryInsights(ticketResults: any[]): Array<{ category: string; relevance: number }> {
  const categoryMap = new Map<string, number>();
  
  ticketResults.forEach((result: any) => {
    const category = result.metadata.category;
    if (category) {
      categoryMap.set(category, (categoryMap.get(category) || 0) + result.similarity_score);
    }
  });
  
  return Array.from(categoryMap.entries())
    .map(([category, score]) => ({ category, relevance: score }))
    .sort((a, b) => b.relevance - a.relevance)
    .slice(0, 3);
}

function generateRelevanceReason(score: number): string {
  if (score > 0.8) return 'Highly relevant based on content similarity';
  if (score > 0.6) return 'Good relevance match';
  if (score > 0.4) return 'Moderate relevance';
  return 'Lower relevance but potentially useful';
}

function generateSuggestedActions(result: any): string[] {
  const actions = [];
  
  if (result.metadata.status === 'Open') {
    actions.push('Review for similar resolution patterns');
  }
  if (result.similarity_score > 0.7) {
    actions.push('Consider as template for current issue');
  }
  
  return actions;
}

function generateApplicabilityText(score: number): string {
  if (score > 0.7) return 'Highly applicable to your query';
  if (score > 0.5) return 'Moderately applicable';
  return 'Potentially relevant information';
}

function enhanceQuery(query: string): string {
  // Simple query enhancement
  return query + ' (enhanced with semantic understanding)';
}